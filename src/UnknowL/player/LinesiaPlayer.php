<?php

namespace UnknowL\player;

use pocketmine\entity\Entity;
use pocketmine\form\Form;
use pocketmine\lang\Translatable;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\nbt\tag\ListTag;
use pocketmine\player\Player;
use pocketmine\scheduler\ClosureTask;
use UnknowL\handlers\dataTypes\PlayerCooldown;
use UnknowL\handlers\Handler;
use UnknowL\Linesia;
use UnknowL\player\manager\StatManager;
use UnknowL\player\manager\EconomyManager;
use UnknowL\rank\Rank;
use UnknowL\handlers\dataTypes\Cooldown;

final class LinesiaPlayer extends Player
{

	private PlayerProperties $properties;

	private EconomyManager $economyManager;

	private StatManager $statManager;

	/***
	 * @var Cooldown[]
	 */
	private array $cooldowns = [];

	private Rank $rank;

	public function initEntity(CompoundTag $nbt): void
	{
		parent::initEntity($nbt);
		$this->properties = new PlayerProperties($this);
		$this->economyManager = new EconomyManager($this);
		$this->statManager = new StatManager($this);
		$this->rank = Handler::RANK()->getRank($this->properties->getProperties("rank"));
		array_map(fn($value) => $this->setBasePermission($value, true), $this->rank->getPermissions());
		$this->properties->setProperties("permissions" ,$this->getRank()->getPermissions());
		$this->loadCooldowns($nbt);
	}

	public function saveNBT(): CompoundTag
	{
		$nbt = parent::saveNBT();
		!isset($this->properties) ?: $this->properties->save($nbt);

		return $nbt;
	}

	final public function kill(): void
	{
		$this->getStatManager()->handleEvents(StatManager::TYPE_DEATH);
		parent::kill();
	}

	final public function attackEntity(Entity $entity): bool
	{
		$result = parent::attackEntity($entity);
		if ($entity instanceof LinesiaPlayer && !$entity->isAlive())
		{
			$this->getStatManager()->handleEvents(StatManager::TYPE_KILL);
		}
		return $result;
	}

	final public function breakBlock(Vector3 $pos): bool
	{
		$result = parent::breakBlock($pos);
		if ($result) $this->getStatManager()->handleEvents(StatManager::TYPE_BLOCK_MINED);
		return $result;
	}

	final public function hasPermission($name): bool
	{
		return in_array($name, $this->getRank()->getPermissions(), true) || parent::hasPermission($name);
	}

	final public function addPermission(string $perm)
	{
		$permissions = $this->getPlayerProperties()->getProperties("permissions");
		$permissions[] = $perm;
		$this->getPlayerProperties()->setProperties("permissions", $perm);
	}

	final public function addCooldown(PlayerCooldown $cooldown, string $path, ...$args): void
	{
		$this->cooldowns[sprintf($path, $args)] = $cooldown;
	}

	final public function getCooldown(string $path, $args): ?Cooldown
	{
		return $this->cooldowns[sprintf($path, $args)] ?? null;
	}

	final public function loadCooldowns(CompoundTag|ListTag $array, $path = ""): void
	{
		foreach ($array->getValue() as $key => $properties)
		{
			if($key === "cooldown" && $properties->getValue() !== "'null'")
			{
				$data = explode(";", $properties->getValue());
				$cooldown = new PlayerCooldown(\DateTime::createFromFormat("d:H:i:s", $data[0]), $this, $data[1], true,
					\DateTime::createFromFormat("d:H:i:s",$data[2]));
				$this->addCooldown($cooldown,empty($path) ? $key : $path);
				return;
			}

			if($properties instanceof CompoundTag || $properties instanceof ListTag)
			{
				$this->loadCooldowns($properties, $path.$key);
			}
		}
	}

	final public function sendForm(Form $form): void
	{
		Linesia::getInstance()->getScheduler()->scheduleDelayedTask(new ClosureTask(function () use ($form) {
			parent::sendForm($form);
		}), 20);
	}

	final public function onUpdate(int $currentTick): bool
	{
		$this->setScoreTag($this->formatNameTag());

		return parent::onUpdate($currentTick);
	}

	private function formatNameTag(): string
	{
		return str_repeat("§a■", round($this->getHealth())) . str_repeat("§c■", round($this->getMaxHealth() - $this->getHealth()));
	}

	final public function onPostDisconnect(Translatable|string $reason, Translatable|string|null $quitMessage): void
	{
		foreach ($this->cooldowns as $cooldown)
		{
			$cooldown->save($this);
		}
		parent::onPostDisconnect($reason, $quitMessage); // TODO: Change the autogenerated stub
	}


	final public function getEconomyManager(): EconomyManager
	{
		return $this->economyManager;
	}

	final public function getPlayerProperties(): PlayerProperties
	{
		return $this->properties;
	}

	final public function getStatManager(): StatManager
	{
		return $this->statManager;
	}

	/**
	 * @return Rank
	 */
	final public function getRank(): Rank
	{
		return $this->rank;
	}

	final public function setRank(Rank $rank): self
	{
		$this->rank = $rank;
		return $this;
	}
}